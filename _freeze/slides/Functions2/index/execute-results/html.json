{
  "hash": "6d6a3c07e3d142fd441720f8e227b23d",
  "result": {
    "markdown": "---\ntitle: \"R Course - Day 3\"\nsubtitle: \"Functions II\"\nformat:\n  emc-revealjs:\n    toc: true\n    toc-depth: 1\n    menu: true\nexecute:\n  echo: true\ncategories: [Day3]\nimage: \"image.png\"\n---\n\n\n## Function environments and scoping {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\nThe Top-Level (or Global) Environment\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- 2\nf <- function(y) {\n  d <- 3\n  return(d * (w + y))\n}\nenvironment(f)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: R_GlobalEnv>\n```\n:::\n:::\n\n\nObjects in the Global Environment:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nobjects()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"f\"               \"has_annotations\" \"w\"              \n```\n:::\n:::\n\n\n## Global and Local Variables {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n`w` is a global variable\n\n`d` is a local variable to `f()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(y) {\n  d <- 3\n  return(d * (w + y))\n}\n\nf(y = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in eval(expr, envir, enclos): object 'd' not found\n```\n:::\n:::\n\n\n## Local preference over Global {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- 2\nd <- 4\n\nf <- function(y) {\n  d <- 3\n  return(d * (w + y))\n}\n\nf(y = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n:::\n\n\n## Local assignment of variables {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- 2\nd <- 4 # This value of d will remain unchanged.\n\nf <- function(y) {\n  d <- 3 # This doesnt affect the value of d in the global environment\n  return(d * (w + y))\n}\n\nf(y = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 9\n```\n:::\n\n```{.r .cell-code}\nd\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4\n```\n:::\n:::\n\n\n## Nested Functions and the Scope Hierarchy {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\nExample:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- 2\nf <- function(y) {\n  d <- 3\n  h <- function() {\n    b <- 5\n    return(d * (w + y))\n  }\n  return(h())\n}\n```\n:::\n\n\n-   `w` is a global environment variable to `f()` and also to `h()`\n\n-   `y` and `d` are local variables to `f()`, but \"global\" to `h()`\n\n-   `b` is local to `h()`\n\n## Check local variables with `ls()` {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- 2\nf <- function(y) {\n  d <- 3\n  h <- function() {\n    b <- 5\n    return(d * (w + y))\n  }\n  print(ls())\n  return(h())\n}\n\nf(y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"d\" \"h\" \"y\"\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n\nNote that `b` is not printed, as it is local to `h()`, but not to `f()`.\n\n## View environment: `environment()` {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nw <- 2\nf <- function(y) {\n  d <- 3\n  h <- function() {\n    b <- 5\n    return(d * (w + y))\n  }\n  print(environment(h))\n  return(h())\n}\nf(y = 2)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n<environment: 0x000001f136aa93c8>\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 12\n```\n:::\n:::\n\n\nShows location in computer memory\n\n## Decorating a function with returns, errors, and warnings {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\nThe following functions are useful for terminating a function call or just printing a warning message:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreturn()     # Terminate a function call and return a value\nstop()       # Terminate a function call and print an error message\nwarning()    # Print a warning message (without terminating the function call)\n```\n:::\n\n\n## Terminating a Function Call Using `return()` {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmySign <- function(x) {\n  if(x < 0) return(\"Negative\")\n  if(x > 0) return(\"Positive\")\n  return(\"Zero\")\n}\n\nmySign(x = 13)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Positive\"\n```\n:::\n:::\n\n\nNote: `return(\"Zero\")` not reached\n\n## Terminating Using `stop()` {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n`stop()` means \"error\"\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyRatio <- function(x, y) {\n  if(y == 0) stop(\"Cannot divide by 0\")\n  return(x/y)\n}\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmyRatio(x = 3, y = 0)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in myRatio(x = 3, y = 0): Cannot divide by 0\n```\n:::\n:::\n\n\nNote: `return(x/y)` not reached\n\n## Printing a Warning Message Using `warning()` {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n`warning()` just prints a warning message.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyRatio <- function(x, y) {\n  if(y == 0) warning(\"Attempt made to divide by 0\")\n  return(x/y)\n}\n\nmyRatio(x = 3, y = 0)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in myRatio(x = 3, y = 0): Attempt made to divide by 0\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] Inf\n```\n:::\n:::\n\n\nR can divide by zero, it returns special value `Inf`\n\n## Looping {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\nRepeat (iterate) an R statement\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor() # Repeat a set of statements a specified number of times\nwhile() # Repeat a set of statements as long as a specified condition is met\nrepeat # Repeat a set of statements until a break command is encountered\n```\n:::\n\n\nStopping a loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nbreak # Terminate a loops iterations\nnext # Skip ahead to the next iteration\n```\n:::\n\n\n## Example `for`, `while` and `repeat` loops {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n::: columns\n\n::: {.column style=\"width: 45%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in 1:5) {\n  print(i^2)\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\nwhile(i <= 5) {\n  print(i^2)\n  i <- i + 1\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n```\n:::\n:::\n\n:::\n\n::: {.column style=\"width: 45%\"}\n\n::: {.cell}\n\n```{.r .cell-code}\ni <- 1\nrepeat {\n  print(i^2)\n  i <- i + 1\n  if(i > 5) break\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1\n[1] 4\n[1] 9\n[1] 16\n[1] 25\n```\n:::\n:::\n\n:::\n\n:::\n\n## for() Loops {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor(i in sequence) {\n  statement1\n  statement2\n  .\n  .\n  .\n  statementq\n}\n```\n:::\n\n\n## \"Looping\" over a `data.frame` {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncoins <- data.frame(Coin = c(\"penny\", \"quarter\", \"nickel\", \"quarter\", \"dime\", \"penny\"),\n                    Year = c(1943, 1905, 1889, 1960, 1937, 1900),\n                    Mint = c(\"Den\", \"SF\", \"Phil\", \"Den\", \"SF\", \"Den\"),\n                    Condition = c(\"good\", \"fair\", \"excellent\", \"good\", \"poor\", \"good\"),\n                    Value = c(12.00, 55.00, 300.00, 40.00, 18.00, 28.00),\n                    Price = c(15.00, 45.00, 375.00, 25.00, 20.00, 20.00))\ncoins\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     Coin Year Mint Condition Value Price\n1   penny 1943  Den      good    12    15\n2 quarter 1905   SF      fair    55    45\n3  nickel 1889 Phil excellent   300   375\n4 quarter 1960  Den      good    40    25\n5    dime 1937   SF      poor    18    20\n6   penny 1900  Den      good    28    20\n```\n:::\n:::\n\n\nCalculate the mean of each column:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolMeans(coins)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in colMeans(coins): 'x' must be numeric\n```\n:::\n:::\n\n\n## Looping Over `data.frame` Columns {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmeans <- NULL\nfor(i in 1:ncol(coins)) {\n  if (is.numeric(coins[ , i])) {\n    means <- c(means, mean(coins[ , i]))\n  }\n}\n\nmeans\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1922.33333   75.50000   83.33333\n```\n:::\n:::\n\n\n## Looping Over List Elements {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmyList <- list(\n  w = c(4, 4, 5, 5, 6, 6),\n  x = c(\"a\", \"b\", \"c\"),\n  y = c(5, 10, 15),\n  z = c(\"r\", \"s\", \"t\", \"u\", \"v\")\n)\n\nlengths <- NULL\n\nfor(i in myList) {\n  print(i)\n  lengths <- c(lengths, length(i))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 4 4 5 5 6 6\n[1] \"a\" \"b\" \"c\"\n[1]  5 10 15\n[1] \"r\" \"s\" \"t\" \"u\" \"v\"\n```\n:::\n\n```{.r .cell-code}\nlengths\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 6 3 3 5\n```\n:::\n:::\n\n\n## Using apply functions {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\nApplying a function to an object\n\n-   `apply()`\n-   `lapply()`\n-   `sapply()`\n-   `tapply()`\n\n## Using apply on matrices {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n`apply()` requires 3 arguments:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nargs(apply)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nfunction (X, MARGIN, FUN, ..., simplify = TRUE) \nNULL\n```\n:::\n:::\n\n\n-   x: the data\n-   MARGIN: `1`, `2`, or `c(1,2)`\n-   function: the function to apply (without the `( )`)\n\n<!-- The apply function works by \"applying\" a specified function to an data object. It requires 3 arguments: the data, a so-called \"MARGIN\", and a function. The data can be a vector, data.frame or a matrix. The MARGIN indicates whether you want to apply the function to the rows or the columns of your data, or both. To apply the function to the rows the MARGIN should be 1, to apply it to the columns it should be 2 and to apply it to both it should be `c(1,2)`. The function can be an existing function, such as `sum()` or `mean()`, or your own custom function. -->\n\n## Applying a function on a matrix {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmat <- matrix(1:25,nrow=5)\n\nmat\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n```\n:::\n:::\n\n\nMargin 1 to apply to the rows:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(mat, 1, max)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 21 22 23 24 25\n```\n:::\n:::\n\n\nMargin 2 to apply to the columns:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(mat, 2, max)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1]  5 10 15 20 25\n```\n:::\n:::\n\n\n## Applying a function to each element: {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(mat, c(1,2), sqrt)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]     [,2]     [,3]     [,4]     [,5]\n[1,] 1.000000 2.449490 3.316625 4.000000 4.582576\n[2,] 1.414214 2.645751 3.464102 4.123106 4.690416\n[3,] 1.732051 2.828427 3.605551 4.242641 4.795832\n[4,] 2.000000 3.000000 3.741657 4.358899 4.898979\n[5,] 2.236068 3.162278 3.872983 4.472136 5.000000\n```\n:::\n:::\n\n\nRemember:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsqrt(mat)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         [,1]     [,2]     [,3]     [,4]     [,5]\n[1,] 1.000000 2.449490 3.316625 4.000000 4.582576\n[2,] 1.414214 2.645751 3.464102 4.123106 4.690416\n[3,] 1.732051 2.828427 3.605551 4.242641 4.795832\n[4,] 2.000000 3.000000 3.741657 4.358899 4.898979\n[5,] 2.236068 3.162278 3.872983 4.472136 5.000000\n```\n:::\n:::\n\n\n## Using lapply on lists to return lists {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmylist <- list(matrix(1:16,nrow=4), matrix(1:9,nrow=3),matrix(1:4,nrow=2))\n\nlapply(mylist, dim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 4 4\n\n[[2]]\n[1] 3 3\n\n[[3]]\n[1] 2 2\n```\n:::\n:::\n\n\n## lapply on a data.frame (list of lists) {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndf <- data.frame(\"col1\"=c(1,1,1,1), \"col2\"=c(2,2,2,2), \"col3\"=c(3,3,3,3))\n\nlapply(df, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$col1\n[1] 4\n\n$col2\n[1] 8\n\n$col3\n[1] 12\n```\n:::\n:::\n\n\n## Using lapply alternative: sapply {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\"Simplify\" lapply output:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(mylist, dim)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     [,1] [,2] [,3]\n[1,]    4    3    2\n[2,]    4    3    2\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(df, sum)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ncol1 col2 col3 \n   4    8   12 \n```\n:::\n:::\n\n\n## Using tapply on groups of data {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatients <- data.frame(\"group\"=paste('grp',\n                          c(1,1,1,1,1,2,2,2,2,2),sep='-'), \n                       \"outcome\"=rnorm(10)) \n                      #10 random normally distributed values\npatients\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   group     outcome\n1  grp-1  1.04874992\n2  grp-1  0.87384415\n3  grp-1  2.15244945\n4  grp-1  0.42963028\n5  grp-1  0.01717816\n6  grp-2 -0.26485904\n7  grp-2  0.54020218\n8  grp-2 -0.29467288\n9  grp-2  0.83249330\n10 grp-2 -1.68409528\n```\n:::\n\n```{.r .cell-code}\ntapply(patients$outcome, patients$group, mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n     grp-1      grp-2 \n 0.9043704 -0.1741863 \n```\n:::\n:::\n\n\n## Multiple grouping variables possible {data-background=\"./_extensions/emc/www/triangle1.svg\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\npatients <- data.frame(\"group\"=paste('grp',c(1,1,1,1,1,2,2,2,2,2),sep='-'),\n                       \"serotype\"=c(\"A\",\"B\",\"A\",\"B\",\"A\",\"B\",\"A\",\"B\",\"A\",\"B\"),\n                       \"outcome\"=rnorm(10))\n\ntapply(patients$outcome, list(patients$group, patients$serotype), mean)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n               A          B\ngrp-1  0.5706276  0.5989575\ngrp-2 -0.4075951 -0.8276507\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\r\n<script>\r\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\r\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\r\n  // slide changes (different for each slide format).\r\n  (function () {\r\n    // dispatch for htmlwidgets\r\n    function fireSlideEnter() {\r\n      const event = window.document.createEvent(\"Event\");\r\n      event.initEvent(\"slideenter\", true, true);\r\n      window.document.dispatchEvent(event);\r\n    }\r\n\r\n    function fireSlideChanged(previousSlide, currentSlide) {\r\n      fireSlideEnter();\r\n\r\n      // dispatch for shiny\r\n      if (window.jQuery) {\r\n        if (previousSlide) {\r\n          window.jQuery(previousSlide).trigger(\"hidden\");\r\n        }\r\n        if (currentSlide) {\r\n          window.jQuery(currentSlide).trigger(\"shown\");\r\n        }\r\n      }\r\n    }\r\n\r\n    // hookup for slidy\r\n    if (window.w3c_slidy) {\r\n      window.w3c_slidy.add_observer(function (slide_num) {\r\n        // slide_num starts at position 1\r\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\r\n      });\r\n    }\r\n\r\n  })();\r\n</script>\r\n\r\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}